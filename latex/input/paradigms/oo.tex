
\frame{\tableofcontents[currentsection, currentsubsection]}

\subsection[Object Oriented]{Object Oriented Programming}

\frame{\tableofcontents[currentsection, currentsubsection]}

\begin{frame}{OOP: Idea}

	\begin{itemize}
		\item Before OOP: Two \stress{separate} entities: \emph{data} and \emph{functions} (logic)
		\item Inspiration: In the {real world}, {objects} have a \enquote{state} (data) and \enquote{behaviors} (functions)
	\end{itemize}

	\begin{block}{OOP}
	\begin{itemize}
		\item \stress{Think} in terms of \hldefn{objects} that contain data and offer \hldefn{methods} (functions that operate on objects) $\lra$ Data and functions form a unit
		\item \stress{Focus} on object structure rather than manipulation logic
		\item \stress{Organize} your code in \hldefn{classes} (blueprints for objects): Every object is \defn{instance} of its class
	\end{itemize}
	\end{block}
	%idea, ..., formal definition, history?
\end{frame}

\begin{frame}[t]{A basic class in python}
	\only<1| handout:0>{\inputminted[lastline=4]{python}{code/paradigms/oop/class_rectangle.py}}
	\only<2| handout:0>{\inputminted[lastline=8]{python}{code/paradigms/oop/class_rectangle.py}}
	\only<3>{\inputminted[]{python}{code/paradigms/oop/class_rectangle.py}}
\end{frame}

\begin{frame}[fragile]{Encapsulation and data hiding}
	% data hiding provides security and avoids data corruption
	%Remember: ... separate interface from implementation ... $\lra$ hide internals

	\begin{itemize}
		\item \hl{Do not expose object internals that may change in the future} $\lra$ Make certain attributes and methods \hhl{private} (\defn{data hiding})
		\item Rephrased: Separate \hhl{interface} (won't be touched because it's used by others) from \hhl{implementation} (might change)
		\item In some languages this is \enquote{enforced} (e.g., using the \verb|private| keyword), in others it is denoted by naming conventions (e.g., leading underscore)
	\end{itemize}
\end{frame}

\begin{frame}[t]{Subclasses and Inheritance}
	\only<1->{\hldefn{Subclasses} are specializations of a class
	\begin{itemize}
		\item inherit attributes/methods of their superclass
		\item can introduce new attributes/methods
		\item can override methods of superclass
	\end{itemize}
	}
	\only<2| handout:0>{\inputminted[fontsize=\footnotesize, lastline=6]{python}{code/paradigms/oop/class_inheritance.py}}
	\only<3>{\inputminted[fontsize=\footnotesize]{python}{code/paradigms/oop/class_inheritance.py}}
\end{frame}

\begin{frame}[t]{Abstract methods}
	\begin{columns}[t]
	\column{0.5\textwidth}
	\begin{itemize}
		\item An \hldefn{abstract method} is a method that has to be implemented by a subclass
		\item<2-> An \hldefn{abstract class} (\hldefn{abstract type}) is a class that cannot be instantiated directly but it might have \hldefn{concrete subclasses} that can
		\item<3-> Use abstract classes to \hl{enforce interfaces} for the concrete classes
	\end{itemize}
	\column{0.5\textwidth}
	\only<1| handout:0>{\inputminted[fontsize=\small, lastline=11]{python}{code/paradigms/oop/class_abstract.py}}
	\only<2->{\inputminted[fontsize=\small]{python}{code/paradigms/oop/class_abstract.py}}
	\end{columns}
\end{frame}

%\begin{frame}{Class methods, class variables}
%	Since this almost only has relevance for using creator patterns, it might be moved to lecture 2
%	\begin{itemize}
%		\item class methods only have access to class variables and other class methods
%		\item important use case: to provide other constructors
%	\end{itemize}
%\end{frame}

\begin{frame}{Strengths and Weaknesses}

\begin{block}{Strengths}
	\only<+->{}
	\begin{itemize}
		\item<+-> \hhl{Easy to read} and understand if done well (very natural way of thinking if classes model real world objects)
		\item<+-> Natural way to \hhl{structure large projects} (e.g., taking classes as components)
		\item<+-> Very \hhl{wide spread} way of thinking
		\item<+-> Especially applicable to problems that center around data and bookkeeping with logic that is strongly tied to the data
	\end{itemize}
\end{block}
\begin{block}{Weaknesses}
\begin{itemize}
	\item<+-> Wrong abstractions can lead to less \hhl{code reusability}
	\item<+-> \hhl{Lasagna code}: Too many layers of classes can be hard to understand
	\item<+-> Can be hard to \hhl{parallelize} if many entangled and interdependent classes with shared mutable states are involved \srem{($\lra$ if required, should be design requirement from the start; \defn{parallel patterns} address some difficulties)}
\end{itemize}
\end{block}
\end{frame}

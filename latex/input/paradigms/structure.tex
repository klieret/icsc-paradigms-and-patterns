\section{Overview}

\begin{frame}{Overview}
	\begin{itemize}
	\item Lecture 1: Programming Paradigms (PPs): Monday 14:15 -- 15:25
	\item Lecture 2: Design Patterns (DPs): Tuesday 14:00 -- 15:10
	\item Exercise consultation time: Thursday 17:00 -- 17:30
	\end{itemize}

	\bigskip
	All material at: \hhl{\href{https://github.com/klieret/icsc-paradigms-and-patterns}{github.com/klieret/icsc-paradigms-and-patterns}}

	\bigskip
	\begin{block}{The goal of this course}
		\begin{itemize}
			\item This course does not try to make you a better programmer
			\item But it \stress{does} convey \hl{basic concepts and vocabulary} to make your design decisions more \stress{consciously}
			\item Thinking while coding + reflecting your decisions after coding $\lra$ Experience $\lra$ Great code!
		\end{itemize}
	\end{block}
\end{frame}



\begin{frame}[t]{Programming Paradigms}
	\only<+->{\begin{block}{What \stress{is} a programming paradigm?}
		\begin{itemize}
			\item A \hhl{classification of programming languages} based on their features {\small (but most popular languages support multiple paradigms)}
			\item A \hhl{programming style} or way programming/thinking
			\item Example: Object Oriented Programming \srem{(thinking in terms of objects which contain data and code)}
			\item Many common languages support \srem{(to some extent)} \hhl{multiple paradigms} \srem{(C++, python, \dots)}
		\end{itemize}
	\end{block}
	}
	%
	\only<+->{\begin{block}{Why should I care?}
			\begin{itemize}
				\item Discover \hhl{new ways of thinking} $\lra$ challenge your current beliefs about how to code
				\item Choose the \hhl{right paradigm for the right problem} or \hhl{pick the best of many worlds}
			\end{itemize}
		\end{block}
	}
	%
\end{frame}

\begin{frame}[t]{Programming Paradigms}
	\only<+->{
	\begin{block}{Some problems}
		\begin{itemize}
			\item Too formal definitions can be hard to grasp and sometimes impractical, too loose definitions can be meaningless
			\item Comparing different paradigms requires experience and knowledge in both \srem{(if all you [know] is a hammer, everything looks like a nail)}
			\item A perfect programmer might write great software using any PP
		\end{itemize}
	\end{block}
	}
	%
	\only<+->{
	\begin{block}{My personal approach}
		\begin{itemize}
			\item Rather than asking \enquote{How to define paradigm X?}, ask \enquote{How would I approach my problems in X?}.
			\item Try out \enquote{academic languages} that enforce a certain paradigm \\\srem{$\lra$ How does it \emph{feel} to program in X}
			\item Get back to your daily programming and rethink your design decisions
		\end{itemize}
	\end{block}
	}
	%

\end{frame}

%\begin{frame}{Lecture 1}{Programming Paradigms}
%	% what is a pp?
%	\begin{enumerate}
%		\setlength{\itemsep}{3ex}
%		\item What do we call "good" code/software?
%		\item Approaches to writing software
%		\item Programming paradigms\vspace{1ex}
%		\begin{enumerate}[a]
%			\setlength{\itemsep}{1ex}
%			\item Object Oriented Programming (OOP)
%			\item Functional Programming (FP)
%			\item OOP vs FP
%			\item Declarative and imperative programming
%			\item Other programming paradigms
%		\end{enumerate}
%	\end{enumerate}
%\end{frame}

\section{Good code}

\frame{\tableofcontents[currentsection, currentsubsection]}

\subsection{Objectives}

%\frame{\tableofcontents[currentsection, currentsubsection]}

\begin{frame}{Good code: Objectives}
\begin{block}{Key objectives}{\relax}
	\begin{itemize}
		\item \hhl{Testability}: Make it easy to \hl{ensure} the software is working correctly
		\item \hhl{Maintainability}: Make it easy to \hl{keep} the software working \srem{(debugging,  readability, ...)}
		\item \hhl{Extendibility}: Make it easy to \hl{add} new functionality
		\item \hhl{Flexibility}: Make it easy to \hl{adapt} to new requirements
		\item \hhl{Reusability}: Make it easy to \hl{reuse} code in other projects
	\end{itemize}
\end{block}

\bigskip
{\Large $\lra$ How do I achieve all this?}

\end{frame}

\subsection{Core concepts}

\begin{frame}[t]{Modularity}{Perhaps the most important principle of good software}
	\hhl{Split up code} into parts, e.g. functions, classes, modules, packages, \dots
	% http://aosd.net/importance-of-modularity-in-programming/

	\bigskip
	You have done \goodc{\stress{well}} if the parts are
	\begin{itemize}
		\item independent of each other
		\item have clear responsibilities
	\end{itemize}

	You have done \badc{\stress{badly}} if the parts
	\begin{itemize}
		\item are very dependent on each other \srem{(changes in one part require changes in many others)}
	\end{itemize}

	\bigskip
	\only<2->{This has benefits for almost all of your goals:
	\begin{itemize}
		\item Easier and more complete \hhl{testability} by using unit tests, better debugging
		\item Confidence from unit tests allows for better \hhl{maintainability} and \hhl{flexibility}
		\item Allowing to split responsibilities for different \enquote{modules} enhances collaboration and thereby \hhl{maintainability}
		\item Code \hhl{reusability} (obvious)
	\end{itemize}
	}
	%high cohesion?


\end{frame}

\begin{frame}{Modularity}{Perhaps the most important principle of good software}
	A related principle: \hhl{Isolate what changes!}

	\begin{itemize}
		\item Which parts of your code will likely have to change in the future?\\
		 \lrapar{These parts should be \hhl{isolated} \srem{(you should be able to change them in one place, without having to change anything else)}}
		 \item This also leads to the concept of a separation of
		 \begin{itemize}
		 	\item \hhl{interface} \srem{(used by other \enquote{modules}, stays untouched)} and
		 	\item \hhl{implementation} \srem{(only used by the module itself, can change easily)}
		 \end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}{Complex vs Complicated}
	% https://medium.com/informed-choises/meta-1-complex-is-better-than-complicated-the-zen-of-python-3663869f8f40
	%
	% https://reinout.vanrees.org/weblog/2015/12/21/complex-complicated.html
	From the Zen of python:

	\bigskip
	\begin{center}
		\hhl{Simple} is better than \hhl{complex}.\\
		\hhl{Complex} is better than \hhl{complicated}.
	\end{center}
	\bigskip

	\begin{itemize}
		\item The more \defn{complicated} something is, the harder it is to understand
		\item The more \defn{complex} something is, the more parts it has
	\end{itemize}

	\bigskip
	\begin{itemize}
		\item Complicated problems might not have simple solutions
		\item But it is often still possible to modularize to have several simple components
	\end{itemize}

	\bigskip
	\begin{itemize}
		\item For example, using classes and objects will make your code more \emph{complex}, but still easier to understand
	\end{itemize}
\end{frame}




